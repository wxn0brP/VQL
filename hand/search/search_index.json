{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VQL (Valthera Query Language): Unifying Data Interactions","text":"<p>Welcome to VQL \u2013 the Valthera Query Language. VQL provides a powerful and flexible framework for interacting with ValtheraDB instances, offering dual query syntaxes, advanced relation handling, and an integrated permission system to build secure and efficient data-driven applications.</p>"},{"location":"#what-is-vql","title":"What is VQL?","text":"<p>VQL acts as an expressive layer on top of ValtheraDB, simplifying complex data operations and ensuring robust security. It allows developers to define data requirements, relations, and access controls in a declarative manner, abstracting away the underlying data fetching and manipulation logic.</p> <p>Whether you're dealing with a single database or orchestrating queries across multiple ValtheraDB instances, VQL streamlines your workflow and enhances data integrity.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Dual Query Syntax:<ul> <li>VQLR (Runtime): A JSON-based object query language ideal for programmatic use and complex, dynamic queries within your application code.</li> <li>VQLS (Simple): A human-readable, string-based language perfect for quick operations, CLI interactions, and simpler scripting needs.</li> </ul> </li> <li>Multi-Database Support: Seamlessly query and process data across several ValtheraDB instances, enabling sophisticated data architectures.</li> <li>Cross-Platform Compatibility: Develop with VQL in both Node.js environments and modern web browsers, ensuring broad applicability.</li> <li>Extensible by Design: Tailor VQL to your specific needs using customizable sheets and configurations, integrating smoothly with your existing systems.</li> <li>Advanced Relation Queries: Go beyond simple joins. VQL natively handles complex relationships not just between collections, but across entirely separate database instances.</li> <li>Integrated Permission System: Powered by Gate Warden, VQL offers granular access control. This powerful system, disabled by default for flexibility, can be activated to enforce intricate security rules at the query level.</li> <li>Falcon Frame Integration: Benefit from extended capabilities and integrations when used alongside Falcon Frame.</li> <li>Dynamic Variable Support: Incorporate predefined or custom variables into your queries, allowing for highly dynamic, reusable, and context-aware data operations.</li> </ul>"},{"location":"#why-choose-vql","title":"Why Choose VQL?","text":"<p>VQL empowers you to:</p> <ul> <li>Simplify Data Access: Write less boilerplate code for common data operations.</li> <li>Enhance Security: Implement fine-grained access control policies directly within your query definitions.</li> <li>Build Scalable Applications: Efficiently manage data interactions across distributed or modular database setups.</li> <li>Improve Developer Experience: Leverage a declarative syntax that makes queries easier to read, write, and maintain.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to Go Next?","text":"<ul> <li>Getting Started: Jump in and learn how to set up VQL and execute your first query.</li> <li>Core Concepts: Understand the fundamental ideas behind VQL, including VQLS, VQLR, and the role of the VQL Processor.</li> <li>VQLS: Dive deep into the syntax and capabilities of the Simple VQL string language.</li> <li>VQLR: Explore the structure and power of the Runtime VQL object format.</li> <li>Permissions: Discover how VQL's integrated permission system can secure your data interactions.</li> <li>HTTP API Integration: Learn how to expose VQL over an HTTP API for use in web applications.</li> </ul>"},{"location":"core_concepts/","title":"Core Concepts of VQL","text":""},{"location":"core_concepts/#what-is-vql","title":"What is VQL?","text":"<p>VQL (Valthera Query Language) is not just a language; it\"s a comprehensive framework for interacting with data stored in ValtheraDB. It provides a unified, secure, and flexible interface for querying and manipulating data, whether you are building a complex backend service or a dynamic front-end application.</p> <p>At its heart, VQL is designed to be a powerful data processing engine. It combines a versatile query language, a robust permissions system, and a set of tools that work together to create a cohesive and efficient data environment.</p>"},{"location":"core_concepts/#the-philosophy-behind-vql","title":"The Philosophy Behind VQL","text":"<p>VQL was built with several core goals in mind:</p> <ol> <li>Unified &amp; Centralized Data Access: Provide a single, consistent way to interact with data across multiple databases. Instead of writing separate logic for each data source, you define it once in a VQL query.</li> <li>Security as a Foundation: Data security is critical. VQL integrates a granular, powerful permission system (Gate Warden) from the ground up. This allows developers to define complex access rules that are enforced automatically with every query, ensuring data is never exposed unintentionally. The system is optional and can be enabled when needed.</li> <li>Flexibility for Every Use Case: VQL offers two distinct syntaxes\u2014VQLR (an object-based syntax for programmatic use) and VQLS (a simpler, human-readable string syntax). This duality allows developers to choose the right tool for the job, from complex application logic to simple scripts.</li> <li>Harnessing the Power of Relations: Modern applications are built on relationships between data. VQL is designed to understand and query these relationships natively, even across different databases, without the complex logic typically required.</li> <li>Extensibility by Design: No two applications are the same. VQL is built to be extensible through custom configurations and \"sheets,\" allowing developers to tailor its functionality to their specific needs.</li> </ol>"},{"location":"core_concepts/#key-architectural-components","title":"Key Architectural Components","text":"<p>VQL\"s architecture consists of several key components that work in concert:</p>"},{"location":"core_concepts/#1-the-vqlprocessor","title":"1. The <code>VQLProcessor</code>","text":"<p>The <code>VQLProcessor</code> is the brain of the entire operation and the main entry point for all interactions. You initialize it with your database instances, and it handles the entire lifecycle of a query.</p> <ul> <li>Takes a query (in either VQLR or VQLS format).</li> <li>Orchestrates the validation, permission checks, execution, and response.</li> <li>Manages the connection to one or more ValtheraDB instances.</li> </ul>"},{"location":"core_concepts/#2-the-query-languages-vqlr-vqls","title":"2. The Query Languages: VQLR &amp; VQLS","text":"<p>VQL provides two ways to write queries to suit different needs.</p> <ul> <li> <p>VQLR (Runtime): A JSON-based object structure that serves as VQL\"s internal AST format. It is ideal for building complex, dynamic queries programmatically within your application code. Its structured nature makes it easy to compose, modify, and integrate with type-safe languages like TypeScript. Learn more about VQLR.</p> </li> <li> <p>VQLS (Simple): A human-readable, one-liner syntax designed for simplicity and speed. It\"s perfect for CLI operations, configuration files, simple scripts, or any scenario where a developer or admin might write a query by hand. Learn more about VQLS.</p> </li> </ul>"},{"location":"core_concepts/#3-the-permission-engine","title":"3. The Permission Engine","text":"<p>Security in VQL is designed to be both powerful and flexible. Instead of relying on static, schema-based rules, VQL employs a programmatic approach. This is achieved by passing a Permission Validation Function (<code>permValidFn</code>) to the <code>VQLProcessor</code>. This function is executed for every data access, giving you dynamic, fine-grained control.</p> <p>To simplify the creation of this function, VQL provides the <code>PermissionResolverEngine</code>, a helper class for building sophisticated validation logic. You can add custom functions (resolvers) that grant or deny access based on data paths, user roles, or the data itself.</p> <p>This system can also be integrated with Gate Warden to create a hybrid model, combining programmatic rules with a more traditional Role-Based Access Control (RBAC) system. Learn how to secure your data with VQL's permission system.</p>"},{"location":"core_concepts/#4-valtheradb-adapters","title":"4. ValtheraDB Adapters","text":"<p>The processor communicates with your databases via internal adapters. This abstraction is what allows VQL to seamlessly query across multiple database instances in a single request, treating them as a unified data pool.</p>"},{"location":"core_concepts/#the-lifecycle-of-a-query","title":"The Lifecycle of a Query","text":"<p>Understanding the flow of a query helps to see how these components fit together:</p> <ol> <li>Query Creation: Your application creates a query as either a VQLS string or a VQLR object. For TypeScript users, the <code>VQLUQ</code> type provides type-safety for either format.</li> <li>Execution: The query is sent to the <code>VQLProcessor</code>\"s <code>.execute()</code> method, along with an optional user context for permission checks.</li> <li>Parsing &amp; Validation: The processor parses the query (if VQLS) and validates its structure.</li> <li>Permission Check: If a <code>permValidFn</code> is configured, it is executed to authorize the request. It checks if the user has the right to access the requested data, potentially denying the query or redacting fields.</li> <li>Data Retrieval: The processor determines which database(s) and collection(s) to target and fetches the raw data from the relevant ValtheraDB instances.</li> <li>Relational Processing: VQL\"s engine processes the results, performing any joins, filtering, or field selections. This is where the power of its relational model comes into play.</li> <li>Response: The final, processed data is returned to your application, containing only the information that the query requested and the user was permitted to see.</li> </ol>"},{"location":"core_concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts of VQL, you're ready to dive deeper.</p> <ul> <li>Getting Started: Follow our hands-on tutorial to execute your first query.</li> <li>VQLS Documentation: Master the simple and fast string-based syntax.</li> <li>VQLR Documentation: Explore the powerful and programmatic object-based syntax.</li> <li>Permissions Guide: Learn how to implement robust, granular security for your data.</li> </ul>"},{"location":"getting_started/","title":"Getting Started: Your First VQL Query","text":"<p>Welcome to the VQL Getting Started guide! This tutorial will walk you through the essential steps to set up VQL, connect it to your ValtheraDB instances, and execute your first queries using both VQLR (Runtime) and VQLS (Simple) syntaxes.</p> <p>By the end of this guide, you will be able to:</p> <ul> <li>Install VQL in your project.</li> <li>Initialize the <code>VQLProcessor</code>.</li> <li>Perform basic <code>find</code> operations with VQLR and VQLS.</li> <li>Understand the structure of VQL queries.</li> </ul>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have: -   Node.js (or preferably Bun) installed. -   A basic understanding of TypeScript/JavaScript. -   <code>ValtheraDB</code> installed and know how to initialize a database instance. You can find its documentation here.</p> <pre><code># Install ValtheraDB if you haven't already\nnpm install @wxn0brp/db # or yarn add @wxn0brp/db, bun add @wxn0brp/db\n</code></pre>"},{"location":"getting_started/#step-1-install-vql","title":"Step 1: Install VQL","text":"<p>First, add VQL to your project's dependencies:</p> <pre><code># Using npm\nnpm install @wxn0brp/vql\n\n# Or using yarn\nyarn add @wxn0brp/vql\n\n# Or using bun\nbun add @wxn0brp/vql\n</code></pre>"},{"location":"getting_started/#step-2-initialize-valtheradb-and-vqlprocessor","title":"Step 2: Initialize ValtheraDB and VQLProcessor","text":"<p>VQL operates on one or more instances of ValtheraDB. Let's create a couple of sample databases and then initialize the <code>VQLProcessor</code>.</p> <p>Create a file named <code>your-first-query.ts</code>:</p> <pre><code>import VQLProcessor, { VQLUQ } from \"@wxn0brp/vql\";\nimport { Valthera } from \"@wxn0brp/db\";\n\n// 1. Initialize ValtheraDB instances\n// Ensure these paths are valid for your environment.\n// ValtheraDB will create these directories if they don't exist.\nconst userDb = new Valthera(\"./data/users-db\");\nconst productDb = new Valthera(\"./data/products-db\");\n\n// You can add some initial data to your databases\nasync function setupData() {\n  await userDb.add(\"users\", { _id: \"user1\", name: \"Alice\", email: \"alice@example.com\", age: 30 });\n  await userDb.add(\"users\", { _id: \"user2\", name: \"Bob\", email: \"bob@example.com\", age: 25 });\n  await productDb.add(\"items\", { _id: \"item1\", name: \"Laptop\", price: 1200, stock: 10 });\n  await productDb.add(\"items\", { _id: \"item2\", name: \"Mouse\", price: 25, stock: 50 });\n  console.log(\"Sample data added to ValtheraDB instances.\");\n}\n\n// 2. Map your database instances to logical names for VQL\nconst dbInstances = {\n  users: userDb,\n  products: productDb,\n};\n\n// 3. Create a VQLProcessor instance\nconst processor = new VQLProcessor(dbInstances);\n\nconsole.log(\"VQL Processor initialized and ready!\");\n\n// Call setupData() before running queries\nsetupData().catch(console.error);\n</code></pre> <p>To run this setup, we recommend using <code>bun</code> as it handles TypeScript execution out of the box without a separate compilation step:</p> <pre><code># In your terminal, run the script directly with bun\nbun run your-first-query.ts\n</code></pre> <p>Alternatively, you can use <code>ts-node</code> or compile with <code>tsc</code> and run with <code>node</code>:</p> <pre><code># Using ts-node\nts-node your-first-query.ts\n\n# Or compile and run with node\ntsc your-first-query.ts\nnode your-first-query.js\n</code></pre> <p>You should see \"Sample data added to ValtheraDB instances.\" and \"VQL Processor initialized and ready!\" in your console. Two directories (<code>data/users-db</code> and <code>data/products-db</code>) will also be created with your data.</p>"},{"location":"getting_started/#step-3-executing-your-first-vqlr-query-object-syntax","title":"Step 3: Executing Your First VQLR Query (Object Syntax)","text":"<p>VQLR is the JSON-based object syntax, often used when constructing queries programmatically. Let's find all users from our <code>users</code> database.</p> <p>For TypeScript users, VQL exports the <code>VQLUQ&lt;T&gt;</code> type, which represents a union of both VQLS (string) and VQLR (object) formats. Using this type provides type-checking and autocompletion for your VQLR queries.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>// ... (previous code for VQLProcessor initialization and setupData) ...\n\nasync function runVQLRQuery() {\n  // Wait for data setup to complete\n  await setupData();\n\n  const queryVQLR: VQLUQ = {\n    db: \"users\", // Target the 'users' database instance\n    d: {\n      find: { // This is the operation type\n        collection: \"users\", // Target the 'users' collection within the 'users' db\n        search: { $gt: { age: 20 } }, // Find users where age is greater than 20\n        fields: { name: 1, email: 1 } // Select only 'name' and 'email' fields\n      },\n    },\n  };\n\n  try {\n    console.log(\"\\nExecuting VQLR query...\");\n    const result = await processor.execute(queryVQLR);\n    console.log(\"VQLR Query Result:\", result);\n  } catch (error) {\n    console.error(\"Error executing VQLR query:\", error);\n  }\n}\n\n// Run the VQLR query\nrunVQLRQuery().catch(console.error);\n</code></pre> <p>Expected Output for the VQLR query:</p> <pre><code>{\n  \"users\": [\n    { \"name\": \"Alice\", \"email\": \"alice@example.com\" },\n    { \"name\": \"Bob\", \"email\": \"bob@example.com\" }\n  ]\n}\n</code></pre>"},{"location":"getting_started/#step-4-executing-your-first-vqls-query-string-syntax","title":"Step 4: Executing Your First VQLS Query (String Syntax)","text":"<p>VQLS is the simple, string-based syntax, great for quick queries or CLI tools. When an operation like <code>find</code> is not specified, it is used by default. Let's find all products from our <code>products</code> database with a price less than 100.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>// ... (previous code for VQLProcessor initialization, setupData, and runVQLRQuery) ...\n\nasync function runVQLSQuery() {\n  // Wait for data setup to complete\n  await setupData(); // Ensure data is set up before running\n\n  // VQLS for finding products with price &lt; 100.\n  // 'find' is the default operation if none is specified.\n  const queryVQLS: VQLUQ = `products items s.$lt.price=100 f.name=1 f.price=1`;\n\n  try {\n    console.log(\"\\nExecuting VQLS query...\");\n    const result = await processor.execute(queryVQLS);\n    console.log(\"VQLS Query Result:\", result);\n  } catch (error) {\n    console.error(\"Error executing VQLS query:\", error);\n  }\n}\n\n// Run the VQLS query\nrunVQLSQuery().catch(console.error);\n</code></pre> <p>Expected Output for the VQLS query:</p> <pre><code>{\n  \"items\": [\n    { \"name\": \"Mouse\", \"price\": 25 }\n  ]\n}\n</code></pre>"},{"location":"getting_started/#step-5-modifying-data-with-vqls","title":"Step 5: Modifying Data with VQLS","text":"<p>VQLS also provides a concise syntax for data modification. Let's update the stock of our \"Mouse\" item from 50 to 45 using the <code>~!</code> (updateOne) operator.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>async function runVQLSUpdateQuery() {\n    // Wait for data setup to complete\n    await setupData();\n\n    // VQLS for updating a single item.\n    // Syntax: &lt;db&gt; ~&lt;collection&gt;~ s.&lt;field&gt;=&lt;val&gt; u.&lt;field&gt;=&lt;val&gt;\n    const updateQuery: VQLUQ = `products ~items! s.name=\"Mouse\" u.stock=45`;\n\n    try {\n        console.log(\"\\nExecuting VQLS update query...\");\n        const result = await processor.execute(updateQuery);\n        console.log(\"VQLS Update Result:\", result);\n\n        // Optional: Verify the change by fetching the updated item\n        const verifyResult = await processor.execute(`products items s.name=\"Mouse\"`);\n        console.log(\"Verified Item:\", verifyResult);\n\n    } catch (error) {\n        console.error(\"Error executing VQLS update query:\", error);\n    }\n}\n\n// Run the VQLS update query\nrunVQLSUpdateQuery().catch(console.error);\n</code></pre> <p>The <code>s.</code> prefix stands for <code>search</code>, specifying the conditions for the update. The <code>u.</code> prefix stands for <code>updater</code>, specifying the fields to change.</p>"},{"location":"getting_started/#congratulations","title":"Congratulations!","text":"<p>You've successfully set up VQL and executed your first queries using both VQLR and VQLS. You're now ready to explore more advanced features.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the fundamental concepts of VQL in Core Concepts.</li> <li>Deep dive into the specific syntax of VQLS and VQLR.</li> <li>Understand how to manage access control with VQL's Permissions.</li> </ul>"},{"location":"integration_http/","title":"HTTP API Integration","text":"<p>VQL is designed to work seamlessly not just within a single application, but also across network boundaries. You can easily expose your <code>VQLProcessor</code> as an HTTP endpoint, allowing frontend applications, microservices, or external scripts to execute queries securely and efficiently.</p> <p>This guide outlines the recommended way to create a VQL-powered API using Falcon Frame on the backend and a lightweight VQL client on the frontend.</p>"},{"location":"integration_http/#server-side-exposing-vql-with-ff_vql","title":"Server-Side: Exposing VQL with <code>FF_VQL</code>","text":"<p>The <code>FF_VQL</code> helper function is the quickest way to create a dedicated VQL endpoint. It handles incoming requests, passes them to the <code>VQLProcessor</code>, and returns the results in a standardized format.</p>"},{"location":"integration_http/#basic-setup","title":"Basic Setup","text":"<p>Here is an example of a simple web server that exposes a VQL endpoint.</p> <p><code>server.ts</code> <pre><code>import { FalconFrame } from \"@wxn0brp/falcon-frame\";\nimport { VQLProcessor, FF_VQL } from \"@wxn0brp/vql\";\nimport { Valthera } from \"@wxn0brp/db\";\n\n// 1. Initialize your Database and VQLProcessor\nconst db = new Valthera(\"./data/my-db\");\nconst processor = new VQLProcessor({ mainDB: db });\n\n// 2. Initialize Falcon Frame\nconst app = new FalconFrame();\n\n// 3. Add the VQL endpoint using the helper\nFF_VQL(app, processor, {\n    // These options are optional\n    path: \"/vql-api\", // Default is \"/VQL\"\n    dev: true // Enables a GET endpoint for debugging queries\n});\n\n// 4. Start the server\napp.l(3000);\n</code></pre></p>"},{"location":"integration_http/#passing-user-context","title":"Passing User Context","text":"<p>A critical feature of <code>FF_VQL</code> is the ability to extract user context from each request and pass it to the <code>VQLProcessor</code> for permission checks. This is done via the <code>getUser</code> option.</p> <p><pre><code>FF_VQL(app, processor, {\n    getUser: async (req) =&gt; {\n        // Example: Extract user info from an Authorization header\n        const token = req.headers.get(\"Authorization\")?.replace(\"Bearer \", \"\");\n\n        if (token === \"SECRET_ADMIN_TOKEN\") {\n            return { _id: \"admin-user\", role: \"admin\" };\n        }\n\n        // For permission resolvers, it's important to provide a context\n        return { _id: \"guest-user\", role: \"guest\" };\n    }\n});\n</code></pre> The object returned by <code>getUser</code> is passed as the <code>user</code> argument to <code>processor.execute()</code> and is available within your permission resolvers.</p>"},{"location":"integration_http/#frontend-using-a-vql-client","title":"Frontend: Using a VQL Client","text":"<p>To communicate with the VQL endpoint from a browser or another service, you should use the official <code>@wxn0brp/vql-client</code> library. This client simplifies interaction with your VQL API, providing convenient functions for sending queries and managing configuration.</p>"},{"location":"integration_http/#installation","title":"Installation","text":"<p>Install the <code>@wxn0brp/vql-client</code> package in your frontend project:</p> <pre><code>npm install @wxn0brp/vql-client\n# or yarn add @wxn0brp/vql-client\n# or bun add @wxn0brp/vql-client\n</code></pre>"},{"location":"integration_http/#core-client-functions","title":"Core Client Functions","text":"<p>The <code>@wxn0brp/vql-client</code> package exports the following key functions and objects:</p> <ul> <li><code>VQLClient.fetchVQL(query, vars)</code>: The primary function for sending queries to the VQL API.<ul> <li><code>query</code>: Can be a VQLS string or a VQLR object. If a string, variables can be provided separately.</li> <li><code>vars</code> (optional): An object containing variables to be substituted in the query (e.g., for <code>s.age=$age</code>).</li> </ul> </li> <li><code>VQLClient.V</code>: A tagged template literal for a more ergonomic, inline VQLS query syntax directly within your code. It's a convenient wrapper around <code>VQLClient.fetchVQL</code>.</li> <li><code>VQLClient.cfg</code>: A global configuration object allowing you to set the endpoint URL (<code>VQLClient.cfg.url</code>), default HTTP headers (<code>VQLClient.cfg.headers</code>), and other options for all client requests.</li> <li><code>VQLClient.defTransport</code>: The default transport function used for making HTTP requests. You can override this for custom networking logic.</li> <li><code>VQLClient.VQLHooks</code>: An interface for defining hooks that can run before, after, or on error of a VQL request. You can set <code>VQLClient.cfg.hooks</code>.</li> </ul>"},{"location":"integration_http/#example-usage","title":"Example Usage","text":"<p>Here\u2019s how you might use the <code>@wxn0brp/vql-client</code> in your frontend JavaScript or TypeScript code.</p> <pre><code>import { VQLClient } from \"@wxn0brp/vql-client\";\n\n// Configure the client to point to your API endpoint\nVQLClient.cfg.url = \"http://localhost:3000/vql-api\";\n\n// Set a default header for authorization\nVQLClient.cfg.headers = {\n    \"Authorization\": \"Bearer SECRET_ADMIN_TOKEN\"\n};\n\nasync function loadData() {\n    try {\n        // Example 1: Use fetchVQL with variables\n        console.log(\"Fetching active users...\");\n        const activeUsers = await VQLClient.fetchVQL(\"mainDB users s.status=$status\", { status: \"active\" });\n        console.log(\"Active Users:\", activeUsers);\n\n        // Example 2: Use the V template literal for a simple query\n        console.log(\"Fetching item by ID...\");\n        const item = await VQLClient.V`mainDB items! s._id=\"item-001\"`;\n        console.log(\"Item:\", item);\n\n    } catch (e) {\n        console.error(\"An error occurred while fetching VQL data:\", e);\n    }\n}\n\nloadData();\n</code></pre> <p>This client-server combination provides a powerful, secure, and maintainable way to build modern data-driven applications with VQL. The server exposes the full power of VQL through a single endpoint, while the client offers a simple and pleasant developer experience for consuming it.</p>"},{"location":"permissions/","title":"Permissions in VQL","text":"<p>VQL implements a highly flexible and powerful programmatic permission system. Instead of static rules defined in a schema, VQL allows you to inject a Permission Validation Function (<code>permValidFn</code>) directly into the <code>VQLProcessor</code>. This function is called for every field being accessed, giving you fine-grained, dynamic control over your data security.</p> <p>To simplify the creation of this validation function, VQL provides the <code>PermissionResolverEngine</code>.</p>"},{"location":"permissions/#permissionresolverengine-the-core-of-custom-logic","title":"<code>PermissionResolverEngine</code>: The Core of Custom Logic","text":"<p>The <code>PermissionResolverEngine</code> is a helper class that lets you build a sophisticated <code>permValidFn</code> by registering custom resolver functions that are matched against data access paths.</p>"},{"location":"permissions/#how-it-works","title":"How It Works","text":"<ol> <li>Instantiate the Engine: Create a new <code>PermissionResolverEngine</code>.</li> <li>Add Resolvers: Use the <code>.addResolver()</code> method to register your permission logic. Each resolver is paired with a <code>matcher</code> that determines when it should be executed.</li> <li>Generate the Validation Function: Use the engine's <code>.create()</code> or <code>.createWithGw()</code> method to generate the final <code>permValidFn</code>.</li> <li>Inject into VQLProcessor: Pass the generated function to the <code>VQLProcessor</code>'s constructor.</li> </ol>"},{"location":"permissions/#step-1-creating-the-permissionresolverengine","title":"Step 1: Creating the <code>PermissionResolverEngine</code>","text":"<p>First, import and create an instance of the engine.</p> <pre><code>import { PermissionResolverEngine } from \"@wxn0brp/vql\";\n\nconst resolverEngine = new PermissionResolverEngine();\n</code></pre>"},{"location":"permissions/#step-2-adding-resolvers","title":"Step 2: Adding Resolvers","text":"<p>This is where you define your security logic. The <code>.addResolver()</code> method takes a <code>matcher</code> and a <code>resolver</code> function.</p>"},{"location":"permissions/#matchers","title":"Matchers","text":"<p>A <code>matcher</code> tells the engine which data paths the resolver should apply to. The path is a string like <code>collection/field</code> (e.g., <code>users/email</code>). A matcher can be: -   A string: For an exact path match (e.g., <code>'users/password'</code>). -   A RegExp: For pattern-based matching (e.g., <code>/email$/</code> to match any field ending in \"email\"). -   A function: For complex, dynamic matching logic <code>(path: string) =&gt; boolean</code>.</p>"},{"location":"permissions/#resolver-function","title":"Resolver Function","text":"<p>A <code>resolver</code> is an <code>async</code> function that returns <code>true</code> (access granted) or <code>false</code> (access denied). It receives a <code>PermValidFnArgs</code> object with the following properties:</p> <ul> <li><code>user</code>: The user object passed to <code>processor.execute()</code>.</li> <li><code>path</code>: The current data path as an array of strings.</li> <li><code>field</code>: The specific field being accessed.</li> <li><code>rootData</code>: The complete data object for the current record being processed.</li> <li><code>p</code>: The permission arguments from the query (if any).</li> </ul>"},{"location":"permissions/#example-adding-different-resolvers","title":"Example: Adding Different Resolvers","text":"<pre><code>// Resolver 1: Block access to any field named 'password' using a RegExp\nresolverEngine.addResolver(/password$/, async (args) =&gt; {\n    // This resolver simply denies access, no matter who the user is.\n    return false;\n});\n\n// Resolver 2: Restrict access to the 'email' field using a string matcher\nresolverEngine.addResolver(\"users/email\", async (args) =&gt; {\n    // Logic: Allow if the user is an admin OR if they are requesting their own email.\n    const { user, rootData } = args;\n    if (user.role === 'admin') {\n        return true;\n    }\n    if (user.id === rootData._id) {\n        return true;\n    }\n    return false;\n});\n\n// Resolver 3: A function-based matcher for any field in a 'logs' collection\nconst logsMatcher = (pathString) =&gt; pathString.startsWith('logs/');\nresolverEngine.addResolver(logsMatcher, async (args) =&gt; {\n    // Logic: Only admins can access anything in the logs.\n    return args.user.role === 'admin';\n});\n</code></pre>"},{"location":"permissions/#step-3-generating-the-permvalidfn","title":"Step 3: Generating the <code>permValidFn</code>","text":"<p>The engine can generate the final validation function in two ways.</p>"},{"location":"permissions/#create","title":"<code>create()</code>","text":"<p>This method creates a <code>permValidFn</code> that uses only the custom resolvers you added.</p> <pre><code>const customPermValidFn = resolverEngine.create();\n</code></pre> <p>If a data path is accessed that does not match any of your resolvers, access will be denied (<code>granted: false, via: 'no-resolver-match'</code>).</p>"},{"location":"permissions/#createwithgwgatewardeninstance","title":"<code>createWithGw(gateWardenInstance)</code>","text":"<p>This method creates a <code>permValidFn</code> that first tries your custom resolvers. If no resolver matches a path, it falls back to a <code>GateWarden</code> instance. This is perfect for combining dynamic, path-based rules with a more traditional Role-Based Access Control (RBAC) system.</p> <pre><code>import { GateWarden } from \"@wxn0brp/gate-warden\";\n\n// Assume 'gw' is a fully configured GateWarden instance\nconst gw = new GateWarden();\n// ... add roles and permissions to gw ...\n\n// Create a validation function that uses custom resolvers and falls back to GateWarden\nconst combinedPermValidFn = resolverEngine.createWithGw(gw);\n</code></pre>"},{"location":"permissions/#step-4-initializing-vqlprocessor","title":"Step 4: Initializing <code>VQLProcessor</code>","text":"<p>Finally, pass your generated <code>permValidFn</code> to the <code>VQLProcessor</code> constructor.</p> <pre><code>import { VQLProcessor, VQLConfig } from \"@wxn0brp/vql\";\n\n// Assume dbInstances and a permValidFn are created\nconst processor = new VQLProcessor(\n    dbInstances,\n    new VQLConfig(), // Optional config\n    combinedPermValidFn // Your generated permission function\n);\n\n// Now, all calls to processor.execute() will be protected by your rules\nasync function runQuery() {\n    const userContext = { id: 'user123', role: 'editor' };\n    const query = /* ... your VQLR or VQLS query ... */;\n\n    // The 'userContext' will be available inside your permission resolvers\n    const result = await processor.execute(query, userContext);\n\n    console.log(result);\n}\n</code></pre> <p>This programmatic approach provides a robust and highly adaptable security model, allowing you to define complex rules that are decoupled from your query logic and schemas.</p>"},{"location":"lang/VQLR/","title":"VQLR (Runtime)","text":""},{"location":"lang/VQLR/#overview","title":"Overview","text":"<p>Internal AST format used by the engine. Used for: - Direct engine interaction - Complex queries beyond DSL capabilities - Query manipulation in code</p>"},{"location":"lang/VQLR/#interface","title":"Interface","text":"<pre><code>interface VQL {\n  r?: {\n    path: [string, string]; // [db, collection]\n    search?: Record&lt;string, any&gt;;\n    select?: Array&lt;string[]&gt;;\n    relations?: Record&lt;string, {\n      path: [string, string];\n      search?: Record&lt;string, any&gt;;\n      select?: string[];\n    }&gt;;\n    options?: { \n      limit?: number;\n    };\n    many: boolean; // find vs findOne (default: false = findOne)\n  };\n\n  db?: string;\n  d?: {\n    [op in \"find\"|\"findOne\"|\"add\"|\"update\"|\"remove\"]: {\n      collection: string;\n      search?: Record&lt;string, any&gt;;\n      data?: Record&lt;string, any&gt;;\n      updater?: Record&lt;string, any&gt;;\n    };\n  };\n}\n</code></pre>"},{"location":"lang/VQLR/#examples","title":"Examples","text":""},{"location":"lang/VQLR/#basic-find-findone","title":"Basic Find (findOne)","text":"<pre><code>const query: VQL = {\n  db: \"db1\",\n  d: {\n    f: { // alias to findOne\n      collection: \"users\",\n      search: { status: \"active\" }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLR/#nested-relations","title":"Nested Relations","text":"<pre><code>const query: VQL = {\n  r: {\n    path: [\"db1\", \"orders\"],\n    relations: {\n      customer: {\n        path: [\"customers\", \"users\"],\n        select: [\"name\", \"email\"]\n      },\n      items: {\n        path: [\"products\", \"items\"],\n        search: { $gt: { stock: 0 } }\n      }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLR/#complex-update","title":"Complex Update","text":"<pre><code>const query: VQL = {\n  d: {\n    update: {\n      collection: \"users\",\n      search: { _id: \"123\" },\n      data: { \n        status: \"inactive\",\n        $inc: { loginCount: true }\n      }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLS/","title":"VQLS (Simple)","text":""},{"location":"lang/VQLS/#overview","title":"Overview","text":"<p>CLI-friendly, one-liner syntax for quick operations.</p>"},{"location":"lang/VQLS/#syntax-components","title":"Syntax Components","text":"<pre><code>&lt;db&gt; &lt;op&gt; &lt;collection&gt; [s.&lt;field&gt;=&lt;val&gt;...] [d.&lt;field&gt;=&lt;val&gt;...] [o.&lt;opt&gt;=&lt;val&gt;...] [r.&lt;rel&gt;=&lt;opts&gt;...]\n</code></pre>"},{"location":"lang/VQLS/#operators","title":"Operators","text":"Prefix/Suffix Operation Example <code>!</code> findOne <code>db1 users! s._id=123</code> <code>+</code> add <code>db1 users d.name=\"Alice\"</code> <code>~</code> update <code>db1 ~users s._id=123 d.name=\"Bob\"</code> <code>~!</code> updateOne <code>db1 ~users! s._id=123 d.name=\"Bob\"</code> <code>-</code> remove <code>db1 -user s._id=123</code> <code>-!</code> removeOne <code>db1 -user! s._id=123</code>"},{"location":"lang/VQLS/#prefixes","title":"Prefixes","text":"Prefix Purpose Example <code>s.</code> Search conditions <code>s.status=\"active\"</code> <code>d.</code> Data payload <code>d.name=\"John\"</code> <code>u.</code> Update payload <code>d.name=\"John\"</code> <code>o.</code> Options <code>o.limit=10</code> <code>r.</code> Relations <code>r.orders.path=[\"db1\", \"orders\"]</code>"},{"location":"lang/VQLS/#examples","title":"Examples","text":"<pre><code># Find active users\ndb1 find users s.status=\"active\" o.limit=5\n\n# Create user\ndb1 +customers d.name=\"Alice\" d.email=\"a@x.com\"\n\n# Update order status\ndb1 ~orders! s._id=999 u.status=\"shipped\"\n\n# Delete inactive users\ndb1 -users s.active=false\n</code></pre>"},{"location":"lang/base/","title":"Valthera Query Language Documentation","text":""},{"location":"lang/base/#table-of-contents","title":"Table of Contents","text":"<ol> <li>VQLS (Simple)</li> <li>VQLR (Runtime)</li> </ol>"},{"location":"lang/base/#map-of-vql-query-types","title":"Map of VQL query types","text":"<ol> <li>VQLS: Simple queries, best to generate from inputs/dropdowns, good for CLI</li> <li>VQLR: Full control, directly interact with execution engine</li> </ol>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VQL (Valthera Query Language): Unifying Data Interactions","text":"<p>Welcome to VQL \u2013 the Valthera Query Language. VQL provides a powerful and flexible framework for interacting with ValtheraDB instances, offering dual query syntaxes, advanced relation handling, and an integrated permission system to build secure and efficient data-driven applications.</p>"},{"location":"#what-is-vql","title":"What is VQL?","text":"<p>VQL acts as an expressive layer on top of ValtheraDB, simplifying complex data operations and ensuring robust security. It allows developers to define data requirements, relations, and access controls in a declarative manner, abstracting away the underlying data fetching and manipulation logic.</p> <p>Whether you're dealing with a single database or orchestrating queries across multiple ValtheraDB instances, VQL streamlines your workflow and enhances data integrity.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Dual Query Syntax:<ul> <li>VQLR (Runtime): A JSON-based object query language ideal for programmatic use and complex, dynamic queries within your application code.</li> <li>VQLS (Simple): A human-readable, string-based language perfect for quick operations, CLI interactions, and simpler scripting needs.</li> </ul> </li> <li>Multi-Database Support: Seamlessly query and process data across several ValtheraDB instances, enabling sophisticated data architectures.</li> <li>Cross-Platform Compatibility: Develop with VQL in both Node.js environments and modern web browsers, ensuring broad applicability.</li> <li>Extensible by Design: Tailor VQL to your specific needs using customizable sheets and configurations, integrating smoothly with your existing systems.</li> <li>Advanced Relation Queries: Go beyond simple joins. VQL natively handles complex relationships not just between collections, but across entirely separate database instances.</li> <li>Integrated Permission System: Powered by Gate Warden, VQL offers granular access control. This powerful system, disabled by default for flexibility, can be activated to enforce intricate security rules at the query level.</li> <li>Falcon Frame Integration: Benefit from extended capabilities and integrations when used alongside Falcon Frame.</li> <li>Dynamic Variable Support: Incorporate predefined or custom variables into your queries, allowing for highly dynamic, reusable, and context-aware data operations.</li> </ul>"},{"location":"#why-choose-vql","title":"Why Choose VQL?","text":"<p>VQL empowers you to:</p> <ul> <li>Simplify Data Access: Write less boilerplate code for common data operations.</li> <li>Enhance Security: Implement fine-grained access control policies directly within your query definitions.</li> <li>Build Scalable Applications: Efficiently manage data interactions across distributed or modular database setups.</li> <li>Improve Developer Experience: Leverage a declarative syntax that makes queries easier to read, write, and maintain.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to Go Next?","text":"<ul> <li>Getting Started: Jump in and learn how to set up VQL and execute your first query.</li> <li>Core Concepts: Understand the fundamental ideas behind VQL, including VQLS, VQLR, and the role of the VQL Processor.</li> <li>VQLS: Dive deep into the syntax and capabilities of the Simple VQL string language.</li> <li>VQLR: Explore the structure and power of the Runtime VQL object format.</li> <li>Permissions: Discover how VQL's integrated permission system can secure your data interactions.</li> </ul>"},{"location":"core_concepts/","title":"Core Concepts of VQL","text":"<p>Understanding VQL revolves around a few fundamental ideas that collectively enable its powerful data interaction capabilities. This section will delve into the primary components: the <code>VQLProcessor</code>, the dual nature of <code>VQLR</code> and <code>VQLS</code> queries, and how VQL handles relations and permissions.</p>"},{"location":"core_concepts/#the-vqlprocessor-the-central-engine","title":"The VQLProcessor: The Central Engine","text":"<p>At the heart of VQL is the <code>VQLProcessor</code>. This is the main class responsible for orchestrating all VQL operations. It acts as an intermediary between your application and your <code>ValtheraDB</code> instances.</p> <p>The <code>VQLProcessor</code> takes your VQL query (either VQLR or VQLS), parses it, applies any configured permissions, resolves relations, and then executes the necessary operations against the specified <code>ValtheraDB</code> instances via their respective adapters.</p> <p>Key Responsibilities of <code>VQLProcessor</code>:</p> <ul> <li>Query Parsing &amp; Validation: Interprets both VQLR objects and VQLS strings into an internal Abstract Syntax Tree (AST).</li> <li>Database Orchestration: Manages multiple <code>ValtheraDB</code> instances, routing queries to the correct database.</li> <li>Relation Resolution: Automatically fetches and merges related data as defined in the query or processor configuration.</li> <li>Permission Enforcement: Applies <code>Gate Warden</code> rules to ensure data access complies with defined security policies.</li> <li>Variable Management: Processes and substitutes variables within queries for dynamic execution.</li> </ul>"},{"location":"core_concepts/#initialization","title":"Initialization","text":"<p>The <code>VQLProcessor</code> is initialized by providing it with a map of named <code>ValtheraDB</code> instances:</p> <pre><code>import VQLProcessor from \"@wxn0brp/vql\";\nimport { Valthera } from \"@wxn0brp/db\";\n\nconst myUserDb = new Valthera(\"./data/my-users-db\");\nconst myProductDb = new Valthera(\"./data/my-products-db\");\n\nconst processor = new VQLProcessor({\n  users: myUserDb,     // 'users' is a logical name for this DB instance\n  products: myProductDb // 'products' is a logical name for this DB instance\n});\n</code></pre>"},{"location":"core_concepts/#vqlr-runtime-vs-vqls-simple-dual-query-syntaxes","title":"VQLR (Runtime) vs. VQLS (Simple): Dual Query Syntaxes","text":"<p>VQL offers two distinct syntaxes to cater to different use cases. Both ultimately translate into an internal representation that the <code>VQLProcessor</code> understands and executes.</p>"},{"location":"core_concepts/#vqlr-runtime-query-language","title":"VQLR (Runtime Query Language)","text":"<ul> <li>Nature: JSON-based object structure.</li> <li>Best For: Programmatic query construction, complex nested queries, dynamic query generation, direct engine interaction.</li> <li>Advantages:<ul> <li>Offers full control over every aspect of the query.</li> <li>Naturally integrates with TypeScript/JavaScript objects, allowing for strong typing and autocompletion.</li> <li>Ideal for building APIs where queries are constructed in code.</li> </ul> </li> <li>Example (Find a user by ID and their posts): <pre><code>const vqlrQuery = {\n  db: \"users\",\n  d: {\n    findOne: {\n      collection: \"users\",\n      search: { _id: \"user123\" },\n      relations: {\n        posts: {\n          path: [\"postsDb\", \"posts\"], // Assuming 'postsDb' is another ValtheraDB instance\n          search: { status: \"published\" },\n          select: [\"title\", \"content\"]\n        }\n      }\n    }\n  }\n};\n</code></pre></li> <li>Detailed Documentation: Refer to VQLR</li> </ul>"},{"location":"core_concepts/#vqls-simple-query-language","title":"VQLS (Simple Query Language)","text":"<ul> <li>Nature: Single-line, human-readable string syntax.</li> <li>Best For: CLI tools, quick ad-hoc queries, logging, simpler scripts, configurations.</li> <li>Advantages:<ul> <li>Highly concise and easy to type.</li> <li>Human-readable, making it suitable for non-developers or command-line interfaces.</li> <li>Excellent for defining simple operations.</li> </ul> </li> <li>Example (Find active products priced under 50): <pre><code>const vqlsQuery = `\n  products find items\n  s.$lt.price=50\n  s.status=\"active\"\n  f.name=1 f.price=1\n`;\n</code></pre></li> <li>Detailed Documentation: Refer to VQLS</li> </ul>"},{"location":"core_concepts/#relations-connecting-your-data","title":"Relations: Connecting Your Data","text":"<p>VQL excels at handling complex data relationships, not just within a single database but across multiple <code>ValtheraDB</code> instances. Unlike a static configuration, relations in VQL are defined dynamically within the query itself, using the top-level <code>r</code> key in a VQLR query. This approach provides maximum flexibility, allowing for ad-hoc and complex data fetching without pre-defining every possible relationship.</p> <p>VQL uses the powerful, battle-tested relation engine from <code>ValtheraDB</code> under the hood. When the processor detects an <code>r</code> key in a query, it passes the query to the <code>executeRelation</code> engine, which fetches and merges the related data as defined in the query.</p>"},{"location":"core_concepts/#example-of-a-relation-query","title":"Example of a Relation Query","text":"<p>This query finds orders and, for each order, resolves the related customer from a different database and the associated product items.</p> <pre><code>const vqlrRelationQuery: VQLUQ = {\n  r: {\n    path: [\"ordersDb\", \"orders\"], // The root collection to query\n    search: { status: \"shipped\" },\n    relations: {\n      // \"customer\" becomes a new field in the results\n      customer: {\n        path: [\"usersDb\", \"users\"], // The related collection in another DB\n        fk: \"customerId\",\n        pk: \"_id\",\n        type: \"1\" // One-to-one relation\n      },\n      // \"items\" becomes a new field in the results\n      items: {\n        path: [\"productsDb\", \"products\"], // Another related collection\n        fk: \"productIds\", // Assumes order.productIds is an array of IDs\n        pk: \"_id\",\n        type: \"1n\" // One-to-many relation\n      }\n    }\n  }\n};\n</code></pre> <p>This declarative, in-query approach eliminates the need for manual \"joins\" in your application logic and allows for fetching deeply nested or cross-database data in a single, predictable operation.</p>"},{"location":"core_concepts/#permissions-secure-by-design","title":"Permissions: Secure by Design","text":"<p>Security is a first-class citizen in VQL. Instead of a schema-based directive system, VQL uses a far more powerful and flexible programmatic approach based on a Permission Validation Function (<code>permValidFn</code>). This function is provided to the <code>VQLProcessor</code> during its construction.</p> <p>At its core, every time VQL tries to access a data field, it calls the <code>permValidFn</code> you provided, asking \"Is access to this field allowed for this user?\". This gives you absolute control over your data security logic.</p>"},{"location":"core_concepts/#the-permissionresolverengine","title":"The <code>PermissionResolverEngine</code>","text":"<p>To make creating the <code>permValidFn</code> easier, VQL provides the <code>PermissionResolverEngine</code>. This engine allows you to register custom resolver functions that are matched against specific data paths.</p> <p>Key Concepts of VQL Permissions: -   Path-Based Matching: Resolvers are triggered based on the path of the data being accessed (e.g., <code>users/email</code>). You can use strings, Regular Expressions, or even custom functions for matching. -   Custom Logic: Your resolver function receives a context object (with your user data) and details about the field being accessed, allowing for any custom logic you need. -   <code>Gate Warden</code> Integration: The engine can be configured to use a <code>GateWarden</code> instance as a fallback, allowing you to combine flexible, path-based rules with a more traditional role-based access control (RBAC) system.</p>"},{"location":"core_concepts/#how-it-works","title":"How It Works","text":"<ol> <li>You create an instance of <code>PermissionResolverEngine</code>.</li> <li>You use <code>.addResolver()</code> to add your custom logic for specific paths.</li> <li>You generate the final <code>permValidFn</code> using <code>.create()</code> or <code>.createWithGw()</code>.</li> <li>You pass this function to the <code>VQLProcessor</code> constructor.</li> </ol> <pre><code>// Example of building a permValidFn\nimport { PermissionResolverEngine } from \"@wxn0brp/vql\";\n\nconst resolverEngine = new PermissionResolverEngine();\n\n// Add a resolver for any field named \"email\"\nresolverEngine.addResolver(/email$/, async (args) =&gt; {\n    // Only admins or the owner can see the email\n    return args.user.role === 'admin' || args.user.id === args.rootData._id;\n});\n\n// Create the validation function\nconst myPermValidFn = resolverEngine.create();\n\n// Pass it to the VQL processor\nconst processor = new VQLProcessor(dbInstances, new VQLConfig(), myPermValidFn);\n</code></pre> <p>This system provides a highly dynamic and powerful way to secure your data, as the logic is decoupled from the queries and schemas themselves. For a detailed guide, see the Permissions page.</p> <p>By understanding these core concepts \u2013 the <code>VQLProcessor</code> as your central hub, the distinct roles of <code>VQLR</code> and <code>VQLS</code>, and VQL's robust handling of relations and permissions \u2013 you are well-equipped to leverage the full power of VQL for your data-driven applications.</p>"},{"location":"core_concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the full capabilities of VQLS for concise queries.</li> <li>Master the comprehensive structure of VQLR for programmatic control.</li> <li>Deep dive into implementing advanced security with Permissions.</li> </ul>"},{"location":"getting_started/","title":"Getting Started: Your First VQL Query","text":"<p>Welcome to the VQL Getting Started guide! This tutorial will walk you through the essential steps to set up VQL, connect it to your ValtheraDB instances, and execute your first queries using both VQLR (Runtime) and VQLS (Simple) syntaxes.</p> <p>By the end of this guide, you will be able to:</p> <ul> <li>Install VQL in your project.</li> <li>Initialize the <code>VQLProcessor</code>.</li> <li>Perform basic <code>find</code> operations with VQLR and VQLS.</li> <li>Understand the structure of VQL queries.</li> </ul>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have: -   Node.js (or preferably Bun) installed. -   A basic understanding of TypeScript/JavaScript. -   <code>ValtheraDB</code> installed and know how to initialize a database instance. You can find its documentation here.</p> <pre><code># Install ValtheraDB if you haven't already\nnpm install @wxn0brp/db # or yarn add @wxn0brp/db, bun add @wxn0brp/db\n</code></pre>"},{"location":"getting_started/#step-1-install-vql","title":"Step 1: Install VQL","text":"<p>First, add VQL to your project's dependencies:</p> <pre><code># Using npm\nnpm install @wxn0brp/vql\n\n# Or using yarn\nyarn add @wxn0brp/vql\n\n# Or using bun\nbun add @wxn0brp/vql\n</code></pre>"},{"location":"getting_started/#step-2-initialize-valtheradb-and-vqlprocessor","title":"Step 2: Initialize ValtheraDB and VQLProcessor","text":"<p>VQL operates on one or more instances of ValtheraDB. Let's create a couple of sample databases and then initialize the <code>VQLProcessor</code>.</p> <p>Create a file named <code>your-first-query.ts</code>:</p> <pre><code>import VQLProcessor, { VQLUQ } from \"@wxn0brp/vql\";\nimport { Valthera } from \"@wxn0brp/db\";\n\n// 1. Initialize ValtheraDB instances\n// Ensure these paths are valid for your environment.\n// ValtheraDB will create these directories if they don't exist.\nconst userDb = new Valthera(\"./data/users-db\");\nconst productDb = new Valthera(\"./data/products-db\");\n\n// You can add some initial data to your databases\nasync function setupData() {\n  await userDb.add(\"users\", { _id: \"user1\", name: \"Alice\", email: \"alice@example.com\", age: 30 });\n  await userDb.add(\"users\", { _id: \"user2\", name: \"Bob\", email: \"bob@example.com\", age: 25 });\n  await productDb.add(\"items\", { _id: \"item1\", name: \"Laptop\", price: 1200, stock: 10 });\n  await productDb.add(\"items\", { _id: \"item2\", name: \"Mouse\", price: 25, stock: 50 });\n  console.log(\"Sample data added to ValtheraDB instances.\");\n}\n\n// 2. Map your database instances to logical names for VQL\nconst dbInstances = {\n  users: userDb,\n  products: productDb,\n};\n\n// 3. Create a VQLProcessor instance\nconst processor = new VQLProcessor(dbInstances);\n\nconsole.log(\"VQL Processor initialized and ready!\");\n\n// Call setupData() before running queries\nsetupData().catch(console.error);\n</code></pre> <p>To run this setup, we recommend using <code>bun</code> as it handles TypeScript execution out of the box without a separate compilation step:</p> <pre><code># In your terminal, run the script directly with bun\nbun run your-first-query.ts\n</code></pre> <p>Alternatively, you can use <code>ts-node</code> or compile with <code>tsc</code> and run with <code>node</code>:</p> <pre><code># Using ts-node\nts-node your-first-query.ts\n\n# Or compile and run with node\ntsc your-first-query.ts\nnode your-first-query.js\n</code></pre> <p>You should see \"Sample data added to ValtheraDB instances.\" and \"VQL Processor initialized and ready!\" in your console. Two directories (<code>data/users-db</code> and <code>data/products-db</code>) will also be created with your data.</p>"},{"location":"getting_started/#step-3-executing-your-first-vqlr-query-object-syntax","title":"Step 3: Executing Your First VQLR Query (Object Syntax)","text":"<p>VQLR is the JSON-based object syntax, often used when constructing queries programmatically. Let's find all users from our <code>users</code> database.</p> <p>For TypeScript users, VQL exports the <code>VQLUQ&lt;T&gt;</code> type, which represents a union of both VQLS (string) and VQLR (object) formats. Using this type provides type-checking and autocompletion for your VQLR queries.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>// ... (previous code for VQLProcessor initialization and setupData) ...\n\nasync function runVQLRQuery() {\n  // Wait for data setup to complete\n  await setupData();\n\n  const queryVQLR: VQLUQ = {\n    db: \"users\", // Target the 'users' database instance\n    d: {\n      find: { // This is the operation type\n        collection: \"users\", // Target the 'users' collection within the 'users' db\n        search: { $gt: { age: 20 } }, // Find users where age is greater than 20\n        fields: { name: 1, email: 1 } // Select only 'name' and 'email' fields\n      },\n    },\n  };\n\n  try {\n    console.log(\"\\nExecuting VQLR query...\");\n    const result = await processor.execute(queryVQLR);\n    console.log(\"VQLR Query Result:\", result);\n  } catch (error) {\n    console.error(\"Error executing VQLR query:\", error);\n  }\n}\n\n// Run the VQLR query\nrunVQLRQuery().catch(console.error);\n</code></pre> <p>Expected Output for the VQLR query:</p> <pre><code>{\n  \"users\": [\n    { \"name\": \"Alice\", \"email\": \"alice@example.com\" },\n    { \"name\": \"Bob\", \"email\": \"bob@example.com\" }\n  ]\n}\n</code></pre>"},{"location":"getting_started/#step-4-executing-your-first-vqls-query-string-syntax","title":"Step 4: Executing Your First VQLS Query (String Syntax)","text":"<p>VQLS is the simple, string-based syntax, great for quick queries or CLI tools. When an operation like <code>find</code> is not specified, it is used by default. Let's find all products from our <code>products</code> database with a price less than 100.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>// ... (previous code for VQLProcessor initialization, setupData, and runVQLRQuery) ...\n\nasync function runVQLSQuery() {\n  // Wait for data setup to complete\n  await setupData(); // Ensure data is set up before running\n\n  // VQLS for finding products with price &lt; 100.\n  // 'find' is the default operation if none is specified.\n  const queryVQLS: VQLUQ = `products items s.$lt.price=100 f.name=1 f.price=1`;\n\n  try {\n    console.log(\"\\nExecuting VQLS query...\");\n    const result = await processor.execute(queryVQLS);\n    console.log(\"VQLS Query Result:\", result);\n  } catch (error) {\n    console.error(\"Error executing VQLS query:\", error);\n  }\n}\n\n// Run the VQLS query\nrunVQLSQuery().catch(console.error);\n</code></pre> <p>Expected Output for the VQLS query:</p> <pre><code>{\n  \"items\": [\n    { \"name\": \"Mouse\", \"price\": 25 }\n  ]\n}\n</code></pre>"},{"location":"getting_started/#step-5-modifying-data-with-vqls","title":"Step 5: Modifying Data with VQLS","text":"<p>VQLS also provides a concise syntax for data modification. Let's update the stock of our \"Mouse\" item from 50 to 45 using the <code>~!</code> (updateOne) operator.</p> <p>Add the following to <code>your-first-query.ts</code>:</p> <pre><code>async function runVQLSUpdateQuery() {\n    // Wait for data setup to complete\n    await setupData();\n\n    // VQLS for updating a single item.\n    // Syntax: &lt;db&gt; ~&lt;collection&gt;~ s.&lt;field&gt;=&lt;val&gt; u.&lt;field&gt;=&lt;val&gt;\n    const updateQuery: VQLUQ = `products ~items! s.name=\"Mouse\" u.stock=45`;\n\n    try {\n        console.log(\"\\nExecuting VQLS update query...\");\n        const result = await processor.execute(updateQuery);\n        console.log(\"VQLS Update Result:\", result);\n\n        // Optional: Verify the change by fetching the updated item\n        const verifyResult = await processor.execute(`products items s.name=\"Mouse\"`);\n        console.log(\"Verified Item:\", verifyResult);\n\n    } catch (error) {\n        console.error(\"Error executing VQLS update query:\", error);\n    }\n}\n\n// Run the VQLS update query\nrunVQLSUpdateQuery().catch(console.error);\n</code></pre> <p>The <code>u.</code> prefix stands for <code>update</code>, specifying the fields to change. The <code>s.</code> prefix works just like in a <code>find</code> query, specifying which document to target.</p> <p>Expected output for the update and verification:</p> <pre><code>// VQLS Update Result: (output may vary, but indicates success)\n{ \"updated\": 1 }\n\n// Verified Item:\n{ \"items\": [ { \"_id\": \"item2\", \"name\": \"Mouse\", \"price\": 25, \"stock\": 45 } ] }\n</code></pre>"},{"location":"getting_started/#congratulations","title":"Congratulations!","text":"<p>You've successfully set up VQL and executed your first queries using both VQLR and VQLS. You're now ready to explore more advanced features.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the fundamental concepts of VQL in Core Concepts.</li> <li>Deep dive into the specific syntax of VQLS and VQLR.</li> <li>Understand how to manage access control with VQL's Permissions.</li> </ul>"},{"location":"permissions/","title":"Permissions in VQL","text":"<p>VQL implements a highly flexible and powerful programmatic permission system. Instead of static rules defined in a schema, VQL allows you to inject a Permission Validation Function (<code>permValidFn</code>) directly into the <code>VQLProcessor</code>. This function is called for every field being accessed, giving you fine-grained, dynamic control over your data security.</p> <p>To simplify the creation of this validation function, VQL provides the <code>PermissionResolverEngine</code>.</p>"},{"location":"permissions/#permissionresolverengine-the-core-of-custom-logic","title":"<code>PermissionResolverEngine</code>: The Core of Custom Logic","text":"<p>The <code>PermissionResolverEngine</code> is a helper class that lets you build a sophisticated <code>permValidFn</code> by registering custom resolver functions that are matched against data access paths.</p>"},{"location":"permissions/#how-it-works","title":"How It Works","text":"<ol> <li>Instantiate the Engine: Create a new <code>PermissionResolverEngine</code>.</li> <li>Add Resolvers: Use the <code>.addResolver()</code> method to register your permission logic. Each resolver is paired with a <code>matcher</code> that determines when it should be executed.</li> <li>Generate the Validation Function: Use the engine's <code>.create()</code> or <code>.createWithGw()</code> method to generate the final <code>permValidFn</code>.</li> <li>Inject into VQLProcessor: Pass the generated function to the <code>VQLProcessor</code>'s constructor.</li> </ol>"},{"location":"permissions/#step-1-creating-the-permissionresolverengine","title":"Step 1: Creating the <code>PermissionResolverEngine</code>","text":"<p>First, import and create an instance of the engine.</p> <pre><code>import { PermissionResolverEngine } from \"@wxn0brp/vql\";\n\nconst resolverEngine = new PermissionResolverEngine();\n</code></pre>"},{"location":"permissions/#step-2-adding-resolvers","title":"Step 2: Adding Resolvers","text":"<p>This is where you define your security logic. The <code>.addResolver()</code> method takes a <code>matcher</code> and a <code>resolver</code> function.</p>"},{"location":"permissions/#matchers","title":"Matchers","text":"<p>A <code>matcher</code> tells the engine which data paths the resolver should apply to. The path is a string like <code>collection/field</code> (e.g., <code>users/email</code>). A matcher can be: -   A string: For an exact path match (e.g., <code>'users/password'</code>). -   A RegExp: For pattern-based matching (e.g., <code>/email$/</code> to match any field ending in \"email\"). -   A function: For complex, dynamic matching logic <code>(path: string) =&gt; boolean</code>.</p>"},{"location":"permissions/#resolver-function","title":"Resolver Function","text":"<p>A <code>resolver</code> is an <code>async</code> function that returns <code>true</code> (access granted) or <code>false</code> (access denied). It receives a <code>PermValidFnArgs</code> object with the following properties:</p> <ul> <li><code>user</code>: The user object passed to <code>processor.execute()</code>.</li> <li><code>path</code>: The current data path as an array of strings.</li> <li><code>field</code>: The specific field being accessed.</li> <li><code>rootData</code>: The complete data object for the current record being processed.</li> <li><code>p</code>: The permission arguments from the query (if any).</li> </ul>"},{"location":"permissions/#example-adding-different-resolvers","title":"Example: Adding Different Resolvers","text":"<pre><code>// Resolver 1: Block access to any field named 'password' using a RegExp\nresolverEngine.addResolver(/password$/, async (args) =&gt; {\n    // This resolver simply denies access, no matter who the user is.\n    return false;\n});\n\n// Resolver 2: Restrict access to the 'email' field using a string matcher\nresolverEngine.addResolver(\"users/email\", async (args) =&gt; {\n    // Logic: Allow if the user is an admin OR if they are requesting their own email.\n    const { user, rootData } = args;\n    if (user.role === 'admin') {\n        return true;\n    }\n    if (user.id === rootData._id) {\n        return true;\n    }\n    return false;\n});\n\n// Resolver 3: A function-based matcher for any field in a 'logs' collection\nconst logsMatcher = (pathString) =&gt; pathString.startsWith('logs/');\nresolverEngine.addResolver(logsMatcher, async (args) =&gt; {\n    // Logic: Only admins can access anything in the logs.\n    return args.user.role === 'admin';\n});\n</code></pre>"},{"location":"permissions/#step-3-generating-the-permvalidfn","title":"Step 3: Generating the <code>permValidFn</code>","text":"<p>The engine can generate the final validation function in two ways.</p>"},{"location":"permissions/#create","title":"<code>create()</code>","text":"<p>This method creates a <code>permValidFn</code> that uses only the custom resolvers you added.</p> <pre><code>const customPermValidFn = resolverEngine.create();\n</code></pre> <p>If a data path is accessed that does not match any of your resolvers, access will be denied (<code>granted: false, via: 'no-resolver-match'</code>).</p>"},{"location":"permissions/#createwithgwgatewardeninstance","title":"<code>createWithGw(gateWardenInstance)</code>","text":"<p>This method creates a <code>permValidFn</code> that first tries your custom resolvers. If no resolver matches a path, it falls back to a <code>GateWarden</code> instance. This is perfect for combining dynamic, path-based rules with a more traditional Role-Based Access Control (RBAC) system.</p> <pre><code>import { GateWarden } from \"@wxn0brp/gate-warden\";\n\n// Assume 'gw' is a fully configured GateWarden instance\nconst gw = new GateWarden();\n// ... add roles and permissions to gw ...\n\n// Create a validation function that uses custom resolvers and falls back to GateWarden\nconst combinedPermValidFn = resolverEngine.createWithGw(gw);\n</code></pre>"},{"location":"permissions/#step-4-initializing-vqlprocessor","title":"Step 4: Initializing <code>VQLProcessor</code>","text":"<p>Finally, pass your generated <code>permValidFn</code> to the <code>VQLProcessor</code> constructor.</p> <pre><code>import { VQLProcessor, VQLConfig } from \"@wxn0brp/vql\";\n\n// Assume dbInstances and a permValidFn are created\nconst processor = new VQLProcessor(\n    dbInstances,\n    new VQLConfig(), // Optional config\n    combinedPermValidFn // Your generated permission function\n);\n\n// Now, all calls to processor.execute() will be protected by your rules\nasync function runQuery() {\n    const userContext = { id: 'user123', role: 'editor' };\n    const query = /* ... your VQLR or VQLS query ... */;\n\n    // The 'userContext' will be available inside your permission resolvers\n    const result = await processor.execute(query, userContext);\n\n    console.log(result);\n}\n</code></pre> <p>This programmatic approach provides a robust and highly adaptable security model, allowing you to define complex rules that are decoupled from your query logic and schemas.</p>"},{"location":"lang/VQLR/","title":"VQLR (Runtime)","text":""},{"location":"lang/VQLR/#overview","title":"Overview","text":"<p>Internal AST format used by the engine. Used for: - Direct engine interaction - Complex queries beyond DSL capabilities - Query manipulation in code</p>"},{"location":"lang/VQLR/#interface","title":"Interface","text":"<pre><code>interface VQL {\n  r?: {\n    path: [string, string]; // [db, collection]\n    search?: Record&lt;string, any&gt;;\n    select?: Array&lt;string[]&gt;;\n    relations?: Record&lt;string, {\n      path: [string, string];\n      search?: Record&lt;string, any&gt;;\n      select?: string[];\n    }&gt;;\n    options?: { \n      limit?: number;\n    };\n    many: boolean; // find vs findOne (default: false = findOne)\n  };\n\n  db?: string;\n  d?: {\n    [op in \"find\"|\"findOne\"|\"add\"|\"update\"|\"remove\"]: {\n      collection: string;\n      search?: Record&lt;string, any&gt;;\n      data?: Record&lt;string, any&gt;;\n      updater?: Record&lt;string, any&gt;;\n    };\n  };\n}\n</code></pre>"},{"location":"lang/VQLR/#examples","title":"Examples","text":""},{"location":"lang/VQLR/#basic-find-findone","title":"Basic Find (findOne)","text":"<pre><code>const query: VQL = {\n  db: \"db1\",\n  d: {\n    f: { // alias to findOne\n      collection: \"users\",\n      search: { status: \"active\" }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLR/#nested-relations","title":"Nested Relations","text":"<pre><code>const query: VQL = {\n  r: {\n    path: [\"db1\", \"orders\"],\n    relations: {\n      customer: {\n        path: [\"customers\", \"users\"],\n        select: [\"name\", \"email\"]\n      },\n      items: {\n        path: [\"products\", \"items\"],\n        search: { $gt: { stock: 0 } }\n      }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLR/#complex-update","title":"Complex Update","text":"<pre><code>const query: VQL = {\n  d: {\n    update: {\n      collection: \"users\",\n      search: { _id: \"123\" },\n      data: { \n        status: \"inactive\",\n        $inc: { loginCount: true }\n      }\n    }\n  }\n};\n</code></pre>"},{"location":"lang/VQLS/","title":"VQLS (Simple)","text":""},{"location":"lang/VQLS/#overview","title":"Overview","text":"<p>CLI-friendly, one-liner syntax for quick operations.</p>"},{"location":"lang/VQLS/#syntax-components","title":"Syntax Components","text":"<pre><code>&lt;db&gt; &lt;op&gt; &lt;collection&gt; [s.&lt;field&gt;=&lt;val&gt;...] [d.&lt;field&gt;=&lt;val&gt;...] [o.&lt;opt&gt;=&lt;val&gt;...] [r.&lt;rel&gt;=&lt;opts&gt;...]\n</code></pre>"},{"location":"lang/VQLS/#operators","title":"Operators","text":"Prefix/Suffix Operation Example <code>!</code> findOne <code>db1 users! s._id=123</code> <code>+</code> add <code>db1 users d.name=\"Alice\"</code> <code>~</code> update <code>db1 ~users s._id=123 d.name=\"Bob\"</code> <code>~!</code> updateOne <code>db1 ~users! s._id=123 d.name=\"Bob\"</code> <code>-</code> remove <code>db1 -user s._id=123</code> <code>-!</code> removeOne <code>db1 -user! s._id=123</code>"},{"location":"lang/VQLS/#prefixes","title":"Prefixes","text":"Prefix Purpose Example <code>s.</code> Search conditions <code>s.status=\"active\"</code> <code>d.</code> Data payload <code>d.name=\"John\"</code> <code>u.</code> Update payload <code>d.name=\"John\"</code> <code>o.</code> Options <code>o.limit=10</code> <code>r.</code> Relations <code>r.orders.path=[\"db1\", \"orders\"]</code>"},{"location":"lang/VQLS/#examples","title":"Examples","text":"<pre><code># Find active users\ndb1 find users s.status=\"active\" o.limit=5\n\n# Create user\ndb1 +customers d.name=\"Alice\" d.email=\"a@x.com\"\n\n# Update order status\ndb1 ~orders! s._id=999 u.status=\"shipped\"\n\n# Delete inactive users\ndb1 -users s.active=false\n</code></pre>"},{"location":"lang/base/","title":"Valthera Query Language Documentation","text":""},{"location":"lang/base/#table-of-contents","title":"Table of Contents","text":"<ol> <li>VQLS (Simple)</li> <li>VQLR (Runtime)</li> </ol>"},{"location":"lang/base/#map-of-vql-query-types","title":"Map of VQL query types","text":"<ol> <li>VQLS: Simple queries, best to generate from inputs/dropdowns, good for CLI</li> <li>VQLR: Full control, directly interact with execution engine</li> </ol>"}]}
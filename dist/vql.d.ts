// Generated by dts-bundle-generator v9.5.1

export interface Data {
	[key: string]: any;
}
export interface VContext {
	[key: string]: any;
}
export type KeysMatching<T, V, C = V> = {
	[K in keyof T]-?: T[K] extends C ? K : never;
}[keyof T];
export type PartialOfType<T, V, C = V> = Partial<Record<KeysMatching<T, V, C>, V>>;
export type PartialPickMatching<T, V, C = V> = Partial<Pick<T, KeysMatching<T, V, C>>>;
/** Logical Operators */
export type LogicalOperators<T = any> = {
	/**
	 * Recursively applies multiple conditions, all of which must evaluate to true.
	 * Can include other operators such as $gt, $exists, or nested $and/$or conditions.
	 */
	$and?: Array<SearchOptions<T>>;
	/**
	 * Recursively applies multiple conditions, at least one of which must evaluate to true.
	 * Can include other operators such as $lt, $type, or nested $and/$or conditions.
	 */
	$or?: Array<SearchOptions<T>>;
	/**
	 * Negates a single condition.
	 * Can include any other operator as its value.
	 */
	$not?: SearchOptions<T>;
};
/** Comparison Operators */
export type ComparisonOperators<T = any> = {
	$gt?: PartialOfType<T, number>;
	$lt?: PartialOfType<T, number>;
	$gte?: PartialOfType<T, number>;
	$lte?: PartialOfType<T, number>;
	$between?: PartialOfType<T, [
		number,
		number
	], number>;
	$in?: Partial<Record<keyof T, T[keyof T][]>>;
	$nin?: Partial<Record<keyof T, T[keyof T][]>>;
};
/** Type and Existence Operators */
export type TypeAndExistenceOperators<T = any> = {
	$exists?: PartialOfType<T, boolean, any>;
	$type?: PartialOfType<T, string>;
};
/** Array Operators */
export type ArrayOperators<T = any> = {
	$arrinc?: PartialPickMatching<T, any[]>;
	$arrincall?: PartialPickMatching<T, any[]>;
	$size?: PartialOfType<T, number>;
};
/** String Operators */
export type StringOperators<T = any> = {
	$regex?: PartialOfType<T, RegExp | string, string>;
	$startsWith?: PartialOfType<T, string>;
	$endsWith?: PartialOfType<T, string>;
};
/** Other Operators */
export type OtherOperators<T = any> = {
	$subset?: Partial<Record<keyof T, T[keyof T]>>;
};
/** Predefined Search Operators */
export type PredefinedSearchOperators<T = any> = LogicalOperators<T> & ComparisonOperators<T> & TypeAndExistenceOperators<T> & ArrayOperators<T> & StringOperators<T> & OtherOperators<T>;
/**
 * SearchOptions can be either a function or an object with predefined operators.
 */
export type SearchOptions<T = any> = PredefinedSearchOperators<T> & Arg<T>;
/** Arrays */
export type ArrayUpdater<T = any> = {
	$push?: PartialOfType<T, any>;
	/** Pushes items into an array and removes duplicates */
	$pushset?: PartialOfType<T, any>;
	$pull?: PartialOfType<T, any>;
	$pullall?: PartialOfType<T, any>;
};
/** Objects */
export type ObjectUpdater<T = any> = {
	$merge?: PartialOfType<T, any[]>;
};
/** Values */
export type ValueUpdater<T = any> = {
	$inc?: PartialOfType<T, number>;
	$dec?: PartialOfType<T, number>;
	$unset?: PartialOfType<T, any>;
	$rename?: PartialOfType<T, any>;
};
export type UpdaterArg<T = any> = ArrayUpdater<T> & ObjectUpdater<T> & ValueUpdater<T> & Arg<T>;
export type Arg<T = any> = {
	[K in keyof T]?: any;
} & Record<string, any>;
export type SearchFunc<T = any> = (data: T, context: VContext) => boolean;
export type UpdaterFunc<T = any> = (data: T, context: VContext) => boolean;
export type Search<T = any> = SearchOptions<T> | SearchFunc<T>;
export type Updater<T = any> = UpdaterArg<T> | UpdaterArg<T>[] | UpdaterFunc<T>;
export interface DbFindOpts<T = any> {
	reverse?: boolean;
	max?: number;
	offset?: number;
	sortBy?: KeysMatching<T, any>;
	sortAsc?: boolean;
}
export interface FindOpts<T = any> {
	select?: KeysMatching<T, any>[];
	exclude?: KeysMatching<T, any>[];
	transform?: Function;
}
declare class CollectionManager<D = Data> {
	private db;
	private collection;
	constructor(db: ValtheraCompatible, collection: string);
	/**
	 * Add data to a database.
	 */
	add<T = Data>(data: Arg<T & D>, id_gen?: boolean): Promise<T>;
	/**
	 * Find data in a database.
	 */
	find<T = Data>(search?: Search<T & D>, options?: DbFindOpts<T & Data>, findOpts?: FindOpts<T & Data>, context?: VContext): Promise<T[]>;
	/**
	 * Find one data entry in a database.
	 */
	findOne<T = Data>(search?: Search<T & Data>, findOpts?: FindOpts<T & Data>, context?: VContext): Promise<T>;
	/**
	 * Update data in a database.
	 */
	update<T = Data>(search: Search<T & Data>, updater: Updater<T & Data>, context?: VContext): Promise<boolean>;
	/**
	 * Update one data entry in a database.
	 */
	updateOne<T = Data>(search: Search<T & Data>, updater: Updater<T & Data>, context?: VContext): Promise<boolean>;
	/**
	 * Remove data from a database.
	 */
	remove<T = Data>(search: Search<T & Data>, context?: VContext): Promise<boolean>;
	/**
	 * Remove one data entry from a database.
	 */
	removeOne<T = Data>(search: Search<T & Data>, context?: VContext): Promise<boolean>;
	/**
	 * Asynchronously updates one entry in a database or adds a new one if it doesn't exist.
	 */
	updateOneOrAdd<T = Data>(search: Search<T & Data>, updater: Updater<T & Data>, { add_arg, context, id_gen }: UpdateOneOrAdd<T & Data>): Promise<boolean>;
}
export interface ValtheraCompatible {
	c(collection: string): CollectionManager;
	getCollections(): Promise<string[]>;
	ensureCollection(collection: string): Promise<boolean>;
	issetCollection(collection: string): Promise<boolean>;
	add<T = Data>(collection: string, data: Arg<T>, id_gen?: boolean): Promise<T>;
	find<T = Data>(collection: string, search?: Search<T>, options?: DbFindOpts<T>, findOpts?: FindOpts<T>, context?: VContext): Promise<T[]>;
	findOne<T = Data>(collection: string, search?: Search<T>, findOpts?: FindOpts<T>, context?: VContext): Promise<T | null>;
	update<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, context?: VContext): Promise<boolean>;
	updateOne<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, context?: VContext): Promise<boolean>;
	remove<T = Data>(collection: string, search: Search<T>, context?: VContext): Promise<boolean>;
	removeOne<T = Data>(collection: string, search: Search<T>, context?: VContext): Promise<boolean>;
	removeCollection(collection: string): Promise<boolean>;
	updateOneOrAdd<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, opts?: UpdateOneOrAdd<T>): Promise<boolean>;
}
export interface UpdateOneOrAdd<T> {
	add_arg?: Arg<T>;
	id_gen?: boolean;
	context?: VContext;
}
declare namespace RelationTypes {
	type Path = [
		string,
		string
	];
	type FieldPath = string[];
	interface DBS {
		[key: string]: ValtheraCompatible;
	}
	interface Relation {
		[key: string]: RelationConfig;
	}
	interface RelationConfig {
		path: Path;
		pk?: string;
		fk?: string;
		as?: string;
		select?: string[];
		findOpts?: DbFindOpts;
		type?: "1" | "11" | "1n" | "nm";
		relations?: Relation;
		through?: {
			table: string;
			db?: string;
			pk: string;
			fk: string;
		};
	}
}
export interface VQL_OP_Find<T = any> {
	collection: string;
	search?: Search<T>;
	limit?: number;
	fields?: VQL_Fields;
	select?: VQL_Fields;
	options?: DbFindOpts<T>;
	searchOpts?: FindOpts<T>;
}
export interface VQL_OP_FindOne<T = any> {
	collection: string;
	search: Search<T>;
	fields?: VQL_Fields;
	select?: VQL_Fields;
	searchOpts?: FindOpts<T>;
}
export interface VQL_OP_Add<T = any> {
	collection: string;
	data: Arg<T>;
	id_gen?: boolean;
}
export interface VQL_OP_Update<T = any> {
	collection: string;
	search: Search<T>;
	updater: UpdaterArg<T>;
}
export interface VQL_OP_Remove<T = any> {
	collection: string;
	search: Search<T>;
}
export interface VQL_OP_UpdateOneOrAdd<T = any> {
	collection: string;
	search: Search<T>;
	updater: UpdaterArg<T>;
	add_arg?: Arg<T>;
	id_gen?: boolean;
}
export interface VQL_OP_CollectionOperation {
	collection: string;
}
export type VQL_Fields = Record<string, boolean | number> | string[];
export type VQL_Query_CRUD_Data<T = any> = {
	find: VQL_OP_Find<T>;
} | {
	findOne: VQL_OP_FindOne<T>;
} | {
	f: VQL_OP_FindOne<T>;
} | {
	add: VQL_OP_Add<T>;
} | {
	update: VQL_OP_Update<T>;
} | {
	updateOne: VQL_OP_Update<T>;
} | {
	remove: VQL_OP_Remove<T>;
} | {
	removeOne: VQL_OP_Remove<T>;
} | {
	updateOneOrAdd: VQL_OP_UpdateOneOrAdd<T>;
} | {
	removeCollection: VQL_OP_CollectionOperation;
} | {
	ensureCollection: VQL_OP_CollectionOperation;
} | {
	issetCollection: VQL_OP_CollectionOperation;
} | {
	getCollections: {};
};
export interface VQL_Query_CRUD<T = any> {
	db: string;
	d: VQL_Query_CRUD_Data<T>;
}
export interface VQL_Query_Relation {
	r: {
		path: RelationTypes.Path;
		search: Search;
		relations: RelationTypes.Relation;
		many?: boolean;
		options?: DbFindOpts;
		select?: RelationTypes.FieldPath[] | Record<string, any>;
	};
}
export interface VQL_Var {
	var?: {
		[k: string]: any;
	};
}
/** VQL Query */
export type VQL_Query<T = any> = (VQL_Query_CRUD<T> | VQL_Query_Relation) & VQL_Var;
/** VQL Universal Query */
export type VQLUQ<T = any> = VQL_Query<T> | string | {
	query: string;
} & VQL_Var;
export interface VQLError {
	err: true;
	msg: string;
	c: number;
}

export {};

// Generated by dts-bundle-generator v9.5.1

export interface Data {
	[key: string]: any;
}
export interface VContext {
	[key: string]: any;
}
export type KeysMatching<T, V, C = V> = {
	[K in keyof T]-?: T[K] extends C ? K : never;
}[keyof T];
/** Helper type for nested path values with type filtering */
export type NestedValue<T, V, C = V> = {
	[K in keyof T as T[K] extends C ? K : T[K] extends object ? K : never]?: T[K] extends C ? V : T[K] extends object ? NestedValue<T[K], V, C> : never;
};
/** Helper type for nested path structure */
export type DeepPartial<T> = {
	[K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
export type JSPrimitiveType = "string" | "number" | "boolean" | "bigint" | "symbol" | "undefined" | "function" | "object";
/** Logical Operators */
export type LogicalOperators<T = any> = {
	/**
	 * Recursively applies multiple conditions, all of which must evaluate to true.
	 * Can include other operators such as $gt, $exists, or nested $and/$or conditions.
	 */
	$and?: Array<SearchOptions<T>>;
	/**
	 * Recursively applies multiple conditions, at least one of which must evaluate to true.
	 * Can include other operators such as $lt, $type, or nested $and/$or conditions.
	 */
	$or?: Array<SearchOptions<T>>;
	/**
	 * Negates a single condition.
	 * Can include any other operator as its value.
	 */
	$not?: SearchOptions<T>;
};
/** Comparison Operators with nested support */
export type ComparisonOperators<T = any> = {
	/** 5 > 4 */
	$gt?: NestedValue<T, number, number>;
	/** 5 < 4 */
	$lt?: NestedValue<T, number, number>;
	/** 5 >= 4 */
	$gte?: NestedValue<T, number, number>;
	/** 5 <= 4 */
	$lte?: NestedValue<T, number, number>;
	/** 5 between [min, max] */
	$between?: NestedValue<T, [
		number,
		number
	], number>;
	/** 2 in [1, 2, 3] */
	$in?: DeepPartial<T> & {
		[K in keyof T]?: T[K] extends any[] ? T[K] : T[K][];
	};
	/** 5 not in [1, 2, 3] */
	$nin?: DeepPartial<T> & {
		[K in keyof T]?: T[K] extends any[] ? T[K] : T[K][];
	};
	/** id > 4 */
	$idGt?: NestedValue<T, string | number, string | number>;
	/** id < 4 */
	$idLt?: NestedValue<T, string | number, string | number>;
	/** id >= 4 */
	$idGte?: NestedValue<T, string | number, string | number>;
	/** id <= 4 */
	$idLte?: NestedValue<T, string | number, string | number>;
};
/** Type and Existence Operators with nested support */
export type TypeAndExistenceOperators<T = any> = {
	/** "name" in { name: "John" } */
	$exists?: NestedValue<T, boolean, any>;
	/** "name" == "string" in { name: "John" } */
	$type?: NestedValue<T, JSPrimitiveType, any>;
};
/** Array Operators with nested support */
export type ArrayOperators<T = any> = {
	/** [1, 2, 3] includes 2 */
	$arrinc?: DeepPartial<T>;
	/** [1, 2, 3] array includes all elements e.g. [1, 2] */
	$arrincall?: DeepPartial<T>;
	/** [1, 2, 3] has size 3 */
	$size?: NestedValue<T, number>;
};
/** String Operators with nested support */
export type StringOperators<T = any> = {
	/** "John" matches /oh/ */
	$regex?: NestedValue<T, RegExp | string, string>;
	/** "John" starts with "Jo" */
	$startsWith?: NestedValue<T, string, string>;
	/** "John" ends with "hn" */
	$endsWith?: NestedValue<T, string, string>;
};
/** Other Operators with nested support */
export type OtherOperators<T = any> = {
	/** { $type: "name" } matches { $type: "name" } literally - Ignore $ operators */
	$subset?: DeepPartial<T>;
};
/** Predefined Search Operators */
export type PredefinedSearchOperators<T = any> = LogicalOperators<T> & ComparisonOperators<T> & TypeAndExistenceOperators<T> & ArrayOperators<T> & StringOperators<T> & OtherOperators<T>;
/**
 * SearchOptions can be either a function or an object with predefined operators.
 */
export type SearchOptions<T = any> = PredefinedSearchOperators<T> & DeepPartial<T> & Record<string, any>;
/** Arrays */
export type ArrayUpdater<T = any> = {
	/** [1,2] -> $push 3 -> [1,2,3] */
	$push?: NestedValue<T, any>;
	/** [1,2] -> $pushset 2,3 -> [1,2,3] */
	$pushset?: NestedValue<T, any>;
	/** [1,2,3] -> $pull 2 -> [1,3] */
	$pull?: NestedValue<T, any>;
	/** [1,2,2,3] -> $pullall [2] -> [1,3] */
	$pullall?: NestedValue<T, any>;
};
/** Objects */
export type ObjectUpdater<T = any> = {
	/** { a: 1 } -> $merge { b: 2 } -> { a: 1, b: 2 } */
	$merge?: NestedValue<T, any>;
	/** { a: { x: 1 } } -> $deepMerge { a: { y: 2 } } -> { a: { x: 1, y: 2 } } */
	$deepMerge?: NestedValue<T, any>;
};
/** Values */
export type ValueUpdater<T = any> = {
	/** { count: 1 } -> $inc 2 -> { count: 3 } */
	$inc?: NestedValue<T, number>;
	/** { count: 5 } -> $dec 2 -> { count: 3 } */
	$dec?: NestedValue<T, number>;
	/** { name: "John" } -> $unset "name" -> {} */
	$unset?: NestedValue<T, any>;
	/** { oldName: "value" } -> $rename "oldName" to "newName" -> { newName: "value" } */
	$rename?: NestedValue<T, any>;
	/**
	 * {} -> $set { name: "John" } -> { name: "John" }
	 *
	 * Note: same as { name: value }
	 */
	$set?: NestedValue<T, any>;
};
export type UpdaterArg<T = any> = ArrayUpdater<T> & ObjectUpdater<T> & ValueUpdater<T> & DeepPartial<T> & Record<string, any>;
export type Arg<T = any> = {
	[K in keyof T]?: any;
} & Record<string, any>;
export type SearchFunc<T = any> = (data: T, context: VContext) => boolean;
export type UpdaterFunc<T = any> = (data: T, context: VContext) => boolean;
export type Search<T = any> = SearchOptions<T> | SearchFunc<T>;
export type Updater<T = any> = UpdaterArg<T> | UpdaterArg<T>[] | UpdaterFunc<T>;
export interface DbFindOpts<T = any> {
	reverse?: boolean;
	limit?: number;
	offset?: number;
	sortBy?: KeysMatching<T, any>;
	sortAsc?: boolean;
}
export interface FindOpts<T = any> {
	select?: KeysMatching<T, any>[];
	exclude?: KeysMatching<T, any>[];
	transform?: Function;
}
declare class CollectionManager<D = Data> {
	private db;
	private collection;
	constructor(db: ValtheraCompatible, collection: string);
	/**
	 * Add data to a database.
	 */
	add(data: Arg<D>, id_gen?: boolean): Promise<D>;
	/**
	 * Find data in a database.
	 */
	find(search?: Search<D>, options?: DbFindOpts<D>, findOpts?: FindOpts<D>, context?: VContext): Promise<D[]>;
	/**
	 * Find one data entry in a database.
	 */
	findOne(search?: Search<D>, findOpts?: FindOpts<D>, context?: VContext): Promise<D>;
	/**
	 * Update data in a database.
	 */
	update(search: Search<D>, updater: Updater<D>, context?: VContext): Promise<boolean>;
	/**
	 * Update one data entry in a database.
	 */
	updateOne(search: Search<D>, updater: Updater<D>, context?: VContext): Promise<boolean>;
	/**
	 * Remove data from a database.
	 */
	remove(search: Search<D>, context?: VContext): Promise<boolean>;
	/**
	 * Remove one data entry from a database.
	 */
	removeOne(search: Search<D>, context?: VContext): Promise<boolean>;
	/**
	 * Asynchronously updates one entry in a database or adds a new one if it doesn't exist.
	 */
	updateOneOrAdd(search: Search<D>, updater: Updater<D>, { add_arg, context, id_gen }?: UpdateOneOrAdd<D>): Promise<boolean>;
	/**
	 * Asynchronously removes one entry in a database or adds a new one if it doesn't exist. Usage e.g. for toggling a flag.
	 */
	toggleOne(search: Search<D>, data?: Arg<D>, context?: VContext): Promise<boolean>;
}
export interface ValtheraCompatible {
	c(collection: string): CollectionManager;
	getCollections(): Promise<string[]>;
	ensureCollection(collection: string): Promise<boolean>;
	issetCollection(collection: string): Promise<boolean>;
	add<T = Data>(collection: string, data: Arg<T>, id_gen?: boolean): Promise<T>;
	find<T = Data>(collection: string, search?: Search<T>, options?: DbFindOpts<T>, findOpts?: FindOpts<T>, context?: VContext): Promise<T[]>;
	findOne<T = Data>(collection: string, search?: Search<T>, findOpts?: FindOpts<T>, context?: VContext): Promise<T | null>;
	update<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, context?: VContext): Promise<boolean>;
	updateOne<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, context?: VContext): Promise<boolean>;
	remove<T = Data>(collection: string, search: Search<T>, context?: VContext): Promise<boolean>;
	removeOne<T = Data>(collection: string, search: Search<T>, context?: VContext): Promise<boolean>;
	removeCollection(collection: string): Promise<boolean>;
	updateOneOrAdd<T = Data>(collection: string, search: Search<T>, updater: Updater<T>, opts?: UpdateOneOrAdd<T>): Promise<boolean>;
	toggleOne<T = Data>(collection: string, search: Search<T>, data?: Arg<T>, context?: VContext): Promise<boolean>;
}
export interface UpdateOneOrAdd<T> {
	add_arg?: Arg<T>;
	id_gen?: boolean;
	context?: VContext;
}
declare namespace RelationTypes {
	type Path = [
		string,
		string
	];
	type FieldPath = string[];
	interface DBS {
		[key: string]: ValtheraCompatible;
	}
	interface Relation {
		[key: string]: RelationConfig;
	}
	interface RelationConfig {
		path: Path;
		pk?: string;
		fk?: string;
		as?: string;
		select?: string[];
		findOpts?: DbFindOpts;
		type?: "1" | "11" | "1n" | "nm";
		relations?: Relation;
		through?: {
			table: string;
			db?: string;
			pk: string;
			fk: string;
		};
	}
}
export interface VQL_OP_Find<T = any> {
	collection: string;
	search?: Search<T>;
	limit?: number;
	fields?: VQL_Fields;
	select?: VQL_Fields;
	options?: DbFindOpts<T>;
	searchOpts?: FindOpts<T>;
}
export interface VQL_OP_FindOne<T = any> {
	collection: string;
	search: Search<T>;
	fields?: VQL_Fields;
	select?: VQL_Fields;
	searchOpts?: FindOpts<T>;
}
export interface VQL_OP_Add<T = any> {
	collection: string;
	data: Arg<T>;
	id_gen?: boolean;
}
export interface VQL_OP_Update<T = any> {
	collection: string;
	search: Search<T>;
	updater: UpdaterArg<T>;
}
export interface VQL_OP_Remove<T = any> {
	collection: string;
	search: Search<T>;
}
export interface VQL_OP_UpdateOneOrAdd<T = any> {
	collection: string;
	search: Search<T>;
	updater: UpdaterArg<T>;
	add_arg?: Arg<T>;
	id_gen?: boolean;
}
export interface VQL_OP_ToggleOne<T = any> {
	collection: string;
	search: Search<T>;
	data?: Arg<T>;
}
export interface VQL_OP_CollectionOperation {
	collection: string;
}
export type VQL_Fields = Record<string, boolean | number> | string[];
export type VQL_Query_CRUD_Data<T = any> = {
	find: VQL_OP_Find<T>;
} | {
	findOne: VQL_OP_FindOne<T>;
} | {
	f: VQL_OP_FindOne<T>;
} | {
	add: VQL_OP_Add<T>;
} | {
	update: VQL_OP_Update<T>;
} | {
	updateOne: VQL_OP_Update<T>;
} | {
	remove: VQL_OP_Remove<T>;
} | {
	removeOne: VQL_OP_Remove<T>;
} | {
	updateOneOrAdd: VQL_OP_UpdateOneOrAdd<T>;
} | {
	toggleOne: VQL_OP_ToggleOne<T>;
} | {
	removeCollection: VQL_OP_CollectionOperation;
} | {
	ensureCollection: VQL_OP_CollectionOperation;
} | {
	issetCollection: VQL_OP_CollectionOperation;
} | {
	getCollections: {};
};
export type VQL_Query_CRUD_Keys = VQL_Query_CRUD_Data extends infer U ? U extends Record<string, unknown> ? keyof U : never : never;
export interface VQL_Query_CRUD<T = any> {
	db: string;
	d: VQL_Query_CRUD_Data<T>;
}
export interface VQL_Query_Relation {
	r: {
		path: RelationTypes.Path;
		search: Search;
		relations: RelationTypes.Relation;
		many?: boolean;
		options?: DbFindOpts;
		select?: RelationTypes.FieldPath[] | Record<string, any>;
	};
}
export interface VQL_Var {
	var?: {
		[k: string]: any;
	};
}
/** VQL Query */
export type VQL_Query<T = any> = (VQL_Query_CRUD<T> | VQL_Query_Relation) & VQL_Var;
/** VQL Universal Query */
export type VQLUQ<T = any> = VQL_Query<T> | string | {
	query: string;
} & VQL_Var;
export interface VQLError {
	err: true;
	msg: string;
	c: number;
}

export {};
